{"version":3,"file":"graphics-extras.js","sources":["../src/drawChamferRect.ts","../src/drawFilletRect.ts","../src/drawRegularPolygon.ts","../src/drawRoundedPolygon.ts","../src/drawRoundedShape.ts","../src/drawStar.ts","../src/drawTorus.ts","../src/index.ts"],"sourcesContent":["import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw Rectangle with chamfer corners. These are angled corners.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawChamferRect\n * @param this\n * @param {number} x - Upper left corner of rect\n * @param {number} y - Upper right corner of rect\n * @param {number} width - Width of rect\n * @param {number} height - Height of rect\n * @param {number} chamfer - non-zero real number, size of corner cutout\n * @returns {PIXI.Graphics} Returns self.\n */\nexport function drawChamferRect(this: Graphics,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    chamfer: number): Graphics\n{\n    if (chamfer <= 0)\n    {\n        return this.drawRect(x, y, width, height);\n    }\n\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n        x + inset, y,\n        right - inset, y,\n        right, y + inset,\n        right, bottom - inset,\n        right - inset, bottom,\n        x + inset, bottom,\n        x, bottom - inset,\n        x, y + inset,\n    ];\n\n    // Remove overlapping points\n    for (let i = points.length - 1; i >= 2; i -= 2)\n    {\n        if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n        {\n            points.splice(i - 1, 2);\n        }\n    }\n\n    return this.drawPolygon(points);\n}\n","import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw Rectangle with fillet corners. This is much like rounded rectangle\n * however it support negative numbers as well for the corner radius.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawFilletRect\n * @param this\n * @param {number} x - Upper left corner of rect\n * @param {number} y - Upper right corner of rect\n * @param {number} width - Width of rect\n * @param {number} height - Height of rect\n * @param {number} fillet - accept negative or positive values\n * @returns {PIXI.Graphics} Returns self.\n */\nexport function drawFilletRect(this: Graphics,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    fillet: number): Graphics\n{\n    if (fillet === 0)\n    {\n        return this.drawRect(x, y, width, height);\n    }\n\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n\n    return this\n        .moveTo(x, y + size)\n        .arcTo(x + dir, y + dir, x + size, y, size)\n        .lineTo(right - size, y)\n        .arcTo(right - dir, y + dir, right, y + size, size)\n        .lineTo(right, bottom - size)\n        .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n        .lineTo(x + size, bottom)\n        .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n        .closePath();\n}\n","import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw a regular polygon where all sides are the same length.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawRegularPolygon\n * @param this\n * @param {number} x - X position\n * @param {number} y - Y position\n * @param {number} radius - Polygon radius\n * @param {number} sides - Minimum value is 3\n * @param {number} rotation - Starting rotation values in radians..\n * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport function drawRegularPolygon(this: Graphics,\n    x: number,\n    y: number,\n    radius: number,\n    sides: number,\n    rotation = 0): Graphics\n{\n    sides = Math.max(sides | 0, 3);\n    const startAngle = (-1 * Math.PI / 2) + rotation;\n    const delta = (Math.PI * 2) / sides;\n    const polygon = [];\n\n    for (let i = 0; i < sides; i++)\n    {\n        const angle = (i * delta) + startAngle;\n\n        polygon.push(\n            x + (radius * Math.cos(angle)),\n            y + (radius * Math.sin(angle))\n        );\n    }\n\n    return this.drawPolygon(polygon);\n}\n","import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw a regular polygon with rounded corners.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawRoundedPolygon\n * @param this\n * @param {number} x - X position\n * @param {number} y - Y position\n * @param {number} radius - Polygon radius\n * @param {number} sides - Minimum value is 3\n * @param {number} corner - Corner size in pixels.\n * @param {number} rotation - Starting rotation values in radians..\n * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport function drawRoundedPolygon(this: Graphics,\n    x: number,\n    y: number,\n    radius: number,\n    sides: number,\n    corner: number,\n    rotation = 0): Graphics\n{\n    sides = Math.max((sides | 0), 3);\n\n    if (corner <= 0)\n    {\n        return this.drawRegularPolygon(x, y, radius, sides, rotation);\n    }\n\n    const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n    corner = Math.min(corner, sideLength);\n\n    const startAngle = (-1 * Math.PI / 2) + rotation;\n    const delta = (Math.PI * 2) / sides;\n    const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n    for (let i = 0; i < sides; i++)\n    {\n        const angle = (i * delta) + startAngle;\n        const x0 = x + (radius * Math.cos(angle));\n        const y0 = y + (radius * Math.sin(angle));\n        const a1 = angle + (Math.PI) + internalAngle;\n        const a2 = angle - (Math.PI) - internalAngle;\n        const x1 = x0 + (corner * Math.cos(a1));\n        const y1 = y0 + (corner * Math.sin(a1));\n        const x3 = x0 + (corner * Math.cos(a2));\n        const y3 = y0 + (corner * Math.sin(a2));\n\n        if (i === 0)\n        {\n            this.moveTo(x1, y1);\n        }\n        else\n        {\n            this.lineTo(x1, y1);\n        }\n        this.quadraticCurveTo(x0, y0, x3, y3);\n    }\n\n    return this.closePath();\n}\n","import type { IPointData } from '@pixi/core';\nimport type { Graphics } from '@pixi/graphics';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param {PIXI.Graphics} g - Graphics to be drawn on.\n * @param {(IPointData & { radius?: number })[]} points - Corners of the shape to draw. Minimum length is 3.\n * @param {number} radius - Corners default radius.\n */\nfunction roundedShapeArc(\n    g: Graphics,\n    points: (IPointData & { radius?: number })[],\n    radius: number\n): void\n{\n    const vecFrom = (p: IPointData, pp: IPointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: IPointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param {PIXI.Graphics} g - Graphics to be drawn on.\n * @param {(IPointData & { radius?: number })[]} points - Corners of the shape to draw. Minimum length is 3.\n * @param {number} radius - Corners default radius.\n */\nfunction roundedShapeQuadraticCurve(\n    g: Graphics,\n    points: (IPointData & { radius?: number })[],\n    radius: number\n): void\n{\n    const distance = (p1: IPointData, p2: IPointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: IPointData, p2: IPointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y);\n    }\n}\n\n/**\n * Draw a Shape with rounded corners.\n * Supports custom radius for each point.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawRoundedShape\n * @param this\n * @param {(IPointData & { radius?: number })[]} points - Corners of the shape to draw. Minimum length is 3.\n * @param {number} radius - Corners default radius.\n * @param {boolean} useQuadraticCurve - If true, rounded corners will be drawn using quadraticCurve instead of arc.\n * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls.\n */\nexport function drawRoundedShape(\n    this: Graphics,\n    points: (IPointData & { radius?: number })[],\n    radius: number,\n    useQuadraticCurve?: boolean\n): Graphics\n{\n    if (points.length < 3)\n    {\n        return this;\n    }\n\n    if (useQuadraticCurve)\n    {\n        roundedShapeQuadraticCurve(this, points, radius);\n    }\n    else\n    {\n        roundedShapeArc(this, points, radius);\n    }\n\n    return this.closePath();\n}\n","import { PI_2, Polygon } from '@pixi/core';\n\nimport type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw a star shape with an arbitrary number of points.\n * @ignore\n */\nclass Star extends Polygon\n{\n    /**\n     * @param x - Center X position of the star\n     * @param y - Center Y position of the star\n     * @param points - The number of points of the star, must be > 1\n     * @param radius - The outer radius of the star\n     * @param innerRadius - The inner radius between points, default half `radius`\n     * @param rotation - The rotation of the star in radians, where 0 is vertical\n     */\n    constructor(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation = 0)\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = PI_2 / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        super(polygon);\n    }\n}\n\n/**\n * Draw a star shape with an arbitrary number of points.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawStar\n * @param this\n * @param x - Center X position of the star\n * @param y - Center Y position of the star\n * @param points - The number of points of the star, must be > 1\n * @param radius - The outer radius of the star\n * @param innerRadius - The inner radius between points, default half `radius`\n * @param rotation - The rotation of the star in radians, where 0 is vertical\n * @returns - This Graphics object. Good for chaining method calls\n */\nexport function drawStar(this: Graphics,\n    x: number,\n    y: number,\n    points: number,\n    radius: number,\n    innerRadius: number,\n    rotation = 0): Graphics\n{\n    return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation) as Polygon);\n}\n","import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw a torus shape, like a donut. Can be used for something like a circle loader.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawTorus\n * @param this\n * @param {number} x - X position\n * @param {number} y - Y position\n * @param {number} innerRadius - Inner circle radius\n * @param {number} outerRadius - Outer circle radius\n * @param {number} [startArc=0] - Where to begin sweep, in radians, 0.0 = to the right\n * @param {number} [endArc=Math.PI*2] - Where to end sweep, in radians\n * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport function drawTorus(this: Graphics,\n    x: number,\n    y: number,\n    innerRadius: number,\n    outerRadius: number,\n    startArc = 0,\n    endArc: number = Math.PI * 2): Graphics\n{\n    if (Math.abs(endArc - startArc) >= Math.PI * 2)\n    {\n        return this\n            .drawCircle(x, y, outerRadius)\n            .beginHole()\n            .drawCircle(x, y, innerRadius)\n            .endHole();\n    }\n\n    this.finishPoly();\n    this\n        .arc(x, y, innerRadius, endArc, startArc, true)\n        .arc(x, y, outerRadius, startArc, endArc, false)\n        .finishPoly();\n\n    return this;\n}\n","/// <reference path=\"../global.d.ts\" />\nimport { Graphics } from '@pixi/graphics';\nimport { drawChamferRect } from './drawChamferRect';\nimport { drawFilletRect } from './drawFilletRect';\nimport { drawRegularPolygon } from './drawRegularPolygon';\nimport { drawRoundedPolygon } from './drawRoundedPolygon';\nimport { drawRoundedShape } from './drawRoundedShape';\nimport { drawStar } from './drawStar';\nimport { drawTorus } from './drawTorus';\n\nexport interface IGraphicsExtras\n{\n    drawTorus: typeof drawTorus;\n    drawChamferRect: typeof drawChamferRect;\n    drawFilletRect: typeof drawFilletRect;\n    drawRegularPolygon: typeof drawRegularPolygon;\n    drawRoundedPolygon: typeof drawRoundedPolygon;\n    drawRoundedShape: typeof drawRoundedShape;\n    drawStar: typeof drawStar;\n}\n\n// Assign extras to Graphics\nObject.defineProperties(Graphics.prototype, {\n    drawTorus: { value: drawTorus },\n    drawChamferRect: { value: drawChamferRect },\n    drawFilletRect: { value: drawFilletRect },\n    drawRegularPolygon: { value: drawRegularPolygon },\n    drawRoundedPolygon: { value: drawRoundedPolygon },\n    drawRoundedShape: { value: drawRoundedShape },\n    drawStar: { value: drawStar },\n});\n"],"names":["Polygon","PI_2","Graphics"],"mappings":";;;;;;;;;AAeO,WAAS,gBACZ,GACA,GACA,OACA,QACA,SACJ;AACI,QAAI,WAAW;AAEX,aAAO,KAAK,SAAS,GAAG,GAAG,OAAO,MAAM;AAG5C,UAAM,QAAQ,KAAK,IAAI,SAAS,KAAK,IAAI,OAAO,MAAM,IAAI,CAAC,GACrD,QAAQ,IAAI,OACZ,SAAS,IAAI,QACb,SAAS;AAAA,MACX,IAAI;AAAA,MAAO;AAAA,MACX,QAAQ;AAAA,MAAO;AAAA,MACf;AAAA,MAAO,IAAI;AAAA,MACX;AAAA,MAAO,SAAS;AAAA,MAChB,QAAQ;AAAA,MAAO;AAAA,MACf,IAAI;AAAA,MAAO;AAAA,MACX;AAAA,MAAG,SAAS;AAAA,MACZ;AAAA,MAAG,IAAI;AAAA,IAAA;AAIX,aAAS,IAAI,OAAO,SAAS,GAAG,KAAK,GAAG,KAAK;AAErC,aAAO,CAAC,MAAM,OAAO,IAAI,CAAC,KAAK,OAAO,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,KAE7D,OAAO,OAAO,IAAI,GAAG,CAAC;AAIvB,WAAA,KAAK,YAAY,MAAM;AAAA,EAClC;ACnCO,WAAS,eACZ,GACA,GACA,OACA,QACA,QACJ;AACI,QAAI,WAAW;AAEX,aAAO,KAAK,SAAS,GAAG,GAAG,OAAO,MAAM;AAG5C,UAAM,YAAY,KAAK,IAAI,OAAO,MAAM,IAAI,GACtC,QAAQ,KAAK,IAAI,WAAW,KAAK,IAAI,CAAC,WAAW,MAAM,CAAC,GACxD,QAAQ,IAAI,OACZ,SAAS,IAAI,QACb,MAAM,QAAQ,IAAI,CAAC,QAAQ,GAC3B,OAAO,KAAK,IAAI,KAAK;AAE3B,WAAO,KACF,OAAO,GAAG,IAAI,IAAI,EAClB,MAAM,IAAI,KAAK,IAAI,KAAK,IAAI,MAAM,GAAG,IAAI,EACzC,OAAO,QAAQ,MAAM,CAAC,EACtB,MAAM,QAAQ,KAAK,IAAI,KAAK,OAAO,IAAI,MAAM,IAAI,EACjD,OAAO,OAAO,SAAS,IAAI,EAC3B,MAAM,QAAQ,KAAK,SAAS,KAAK,IAAI,QAAQ,MAAM,QAAQ,IAAI,EAC/D,OAAO,IAAI,MAAM,MAAM,EACvB,MAAM,IAAI,KAAK,SAAS,KAAK,GAAG,SAAS,MAAM,IAAI,EACnD,UAAU;AAAA,EACnB;AC9BO,WAAS,mBACZ,GACA,GACA,QACA,OACA,WAAW,GACf;AACI,YAAQ,KAAK,IAAI,QAAQ,GAAG,CAAC;AAC7B,UAAM,aAAc,KAAK,KAAK,KAAK,IAAK,UAClC,QAAS,KAAK,KAAK,IAAK,OACxB,UAAU,CAAA;AAEhB,aAAS,IAAI,GAAG,IAAI,OAAO,KAC3B;AACU,YAAA,QAAS,IAAI,QAAS;AAEpB,cAAA;AAAA,QACJ,IAAK,SAAS,KAAK,IAAI,KAAK;AAAA,QAC5B,IAAK,SAAS,KAAK,IAAI,KAAK;AAAA,MAAA;AAAA,IAEpC;AAEO,WAAA,KAAK,YAAY,OAAO;AAAA,EACnC;ACtBO,WAAS,mBACZ,GACA,GACA,QACA,OACA,QACA,WAAW,GACf;AAGI,QAFA,QAAQ,KAAK,IAAK,QAAQ,GAAI,CAAC,GAE3B,UAAU;AAEV,aAAO,KAAK,mBAAmB,GAAG,GAAG,QAAQ,OAAO,QAAQ;AAGhE,UAAM,aAAc,SAAS,KAAK,IAAI,KAAK,KAAK,KAAK,IAAK;AAEjD,aAAA,KAAK,IAAI,QAAQ,UAAU;AAEpC,UAAM,aAAc,KAAK,KAAK,KAAK,IAAK,UAClC,QAAS,KAAK,KAAK,IAAK,OACxB,iBAAkB,QAAQ,KAAK,KAAK,KAAM,QAAQ;AAExD,aAAS,IAAI,GAAG,IAAI,OAAO,KAC3B;AACU,YAAA,QAAS,IAAI,QAAS,YACtB,KAAK,IAAK,SAAS,KAAK,IAAI,KAAK,GACjC,KAAK,IAAK,SAAS,KAAK,IAAI,KAAK,GACjC,KAAK,QAAS,KAAK,KAAM,eACzB,KAAK,QAAS,KAAK,KAAM,eACzB,KAAK,KAAM,SAAS,KAAK,IAAI,EAAE,GAC/B,KAAK,KAAM,SAAS,KAAK,IAAI,EAAE,GAC/B,KAAK,KAAM,SAAS,KAAK,IAAI,EAAE,GAC/B,KAAK,KAAM,SAAS,KAAK,IAAI,EAAE;AAEjC,YAAM,IAEN,KAAK,OAAO,IAAI,EAAE,IAIlB,KAAK,OAAO,IAAI,EAAE,GAEtB,KAAK,iBAAiB,IAAI,IAAI,IAAI,EAAE;AAAA,IACxC;AAEA,WAAO,KAAK;EAChB;ACrDA,WAAS,gBACL,GACA,QACA,QAEJ;AAfA,QAAA;AAgBU,UAAA,UAAU,CAAC,GAAe,OAChC;AACU,YAAA,IAAI,GAAG,IAAI,EAAE,GACb,IAAI,GAAG,IAAI,EAAE,GACb,MAAM,KAAK,KAAM,IAAI,IAAM,IAAI,CAAE,GACjC,KAAK,IAAI,KACT,KAAK,IAAI;AAER,aAAA,EAAE,KAAK,IAAI;IAAG,GAGnB,cAAc,CAAC,GAAW,MAChC;AACQ,YAAM,IAEN,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,IAIjB,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC;AAAA,IAAA;AAIzB,QAAI,KAAK,OAAO,OAAO,SAAS,CAAC;AAEjC,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KACnC;AACU,YAAA,KAAK,OAAO,IAAI,OAAO,MAAM,GAC7B,WAAU,KAAG,GAAA,WAAH,OAAa,KAAA;AAE7B,UAAI,WAAW,GACf;AACgB,oBAAA,GAAG,EAAE,GACjB,KAAK;AACL;AAAA,MACJ;AAEA,YAAM,KAAK,QAAQ,IAAI,KAAK,OAAO,MAAM,GACnC,KAAK,QAAQ,IAAI,EAAE,GACnB,KAAK,QAAQ,IAAI,EAAE;AAEzB,UAAI,GAAG,MAAM,QAAQ,GAAG,MAAM,MAC9B;AACgB,oBAAA,GAAG,EAAE,GACjB,KAAK;AACL;AAAA,MACJ;AAEA,UAAI,QAAQ,KAAK,KAAM,GAAG,KAAK,GAAG,KAAO,GAAG,KAAK,GAAG,EAAG,GACnD,eAAe,GACf,gBAAgB;AAEf,SAAG,KAAK,GAAG,KAAO,GAAG,KAAK,CAAC,GAAG,KAAM,IAEjC,QAAQ,IAER,QAAQ,KAAK,KAAK,SAIlB,QAAQ,KAAK,KAAK,OAClB,eAAe,IACf,gBAAgB,MAGf,QAAQ,MAEb,eAAe,IACf,gBAAgB;AAGpB,YAAM,YAAY,QAAQ;AAEtB,UAAA,SACA,SAAS,KAAK;AAAA,QACb,KAAK,IAAI,SAAS,IAAI,UAAW,KAAK,IAAI,SAAS;AAAA,MAAA;AAGpD,eAAS,KAAK,IAAI,GAAG,MAAM,GAAG,GAAG,MAAM,CAAC,KAExC,SAAS,KAAK,IAAI,GAAG,MAAM,GAAG,GAAG,MAAM,CAAC,GACxC,UAAU,KAAK,IAAK,SAAS,KAAK,IAAI,SAAS,IAAK,KAAK,IAAI,SAAS,CAAC,KAIvE,UAAU;AAGd,YAAM,KAAK,GAAG,IAAK,GAAG,KAAK,SAAW,CAAC,GAAG,KAAK,UAAU,cACnD,KAAK,GAAG,IAAK,GAAG,KAAK,SAAW,GAAG,KAAK,UAAU,cAClD,aAAa,KAAK,MAAM,GAAG,IAAI,GAAG,EAAE,IAAM,KAAK,KAAK,IAAK,cACzD,WAAW,KAAK,MAAM,GAAG,IAAI,GAAG,EAAE,IAAM,KAAK,KAAK,IAAK;AAEzD,YAAM,KAEN,EAAE;AAAA,QACE,KAAM,KAAK,IAAI,UAAU,IAAI;AAAA,QAC7B,KAAM,KAAK,IAAI,UAAU,IAAI;AAAA,MACjC,GAGJ,EAAE,IAAI,IAAI,IAAI,SAAS,YAAY,UAAU,aAAa,GAE1D,KAAK;AAAA,IACT;AAAA,EACJ;AASA,WAAS,2BACL,GACA,QACA,QAEJ;AAvIA,QAAA;AAwIU,UAAA,WAAW,CAAC,IAAgB,OAC9B,KAAK,MAAO,GAAG,IAAI,GAAG,MAAM,KAAO,GAAG,IAAI,GAAG,MAAM,CAAE,GAEnD,YAAY,CAAC,IAAgB,IAAgB,OAAe;AAAA,MAC9D,GAAG,GAAG,KAAM,GAAG,IAAI,GAAG,KAAK;AAAA,MAC3B,GAAG,GAAG,KAAM,GAAG,IAAI,GAAG,KAAK;AAAA,IAAA,IAGzB,YAAY,OAAO;AAEzB,aAAS,IAAI,GAAG,IAAI,WAAW,KAC/B;AACU,YAAA,YAAY,QAAQ,IAAI,KAAK,SAAS,GACtC,WAAU,KAAU,UAAA,WAAV,OAAoB,KAAA;AAEpC,UAAI,WAAW,GACf;AACQ,cAAM,IAEN,EAAE,OAAO,UAAU,GAAG,UAAU,CAAC,IAIjC,EAAE,OAAO,UAAU,GAAG,UAAU,CAAC;AAGrC;AAAA,MACJ;AAEA,YAAM,YAAY,OAAO,CAAC,GACpB,YAAY,QAAQ,IAAI,KAAK,SAAS,GAEtC,iBAAiB,SAAS,WAAW,SAAS;AAChD,UAAA;AAEJ,UAAI,iBAAiB;AAET,gBAAA;AAAA,WAGZ;AACI,cAAM,qBAAqB,KAAK,IAAI,iBAAiB,GAAG,OAAO;AAEvD,gBAAA;AAAA,UACJ;AAAA,UACA;AAAA,UACA,qBAAqB;AAAA,QAAA;AAAA,MAE7B;AAEM,YAAA,iBAAiB,SAAS,WAAW,SAAS;AAChD,UAAA;AAEJ,UAAI,iBAAiB;AAEX,cAAA;AAAA,WAGV;AACI,cAAM,qBAAqB,KAAK,IAAI,iBAAiB,GAAG,OAAO;AAEzD,cAAA;AAAA,UACF;AAAA,UACA;AAAA,UACA,qBAAqB;AAAA,QAAA;AAAA,MAE7B;AAEI,YAAM,IAEN,EAAE,OAAO,MAAM,GAAG,MAAM,CAAC,IAIzB,EAAE,OAAO,MAAM,GAAG,MAAM,CAAC,GAE7B,EAAE,iBAAiB,UAAU,GAAG,UAAU,GAAG,IAAI,GAAG,IAAI,CAAC;AAAA,IAC7D;AAAA,EACJ;AAcgB,WAAA,iBAEZ,QACA,QACA,mBAEJ;AACI,WAAI,OAAO,SAAS,IAET,QAGP,oBAEA,2BAA2B,MAAM,QAAQ,MAAM,IAI/C,gBAAgB,MAAM,QAAQ,MAAM,GAGjC,KAAK,UAAU;AAAA,EAC1B;AAAA,EClPA,MAAM,aAAaA,KAAAA,QACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IASI,YAAY,GAAW,GAAW,QAAgB,QAAgB,aAAsB,WAAW,GACnG;AACI,oBAAc,eAAe,SAAS;AAEtC,YAAM,aAAc,KAAK,KAAK,KAAK,IAAK,UAClC,MAAM,SAAS,GACf,QAAQC,KAAO,OAAA,KACf,UAAU;AAEhB,eAAS,IAAI,GAAG,IAAI,KAAK,KACzB;AACI,cAAM,IAAI,IAAI,IAAI,cAAc,QAC1B,QAAS,IAAI,QAAS;AAEpB,gBAAA;AAAA,UACJ,IAAK,IAAI,KAAK,IAAI,KAAK;AAAA,UACvB,IAAK,IAAI,KAAK,IAAI,KAAK;AAAA,QAAA;AAAA,MAE/B;AAEA,YAAM,OAAO;AAAA,IACjB;AAAA,EACJ;AAgBO,WAAS,SACZ,GACA,GACA,QACA,QACA,aACA,WAAW,GACf;AACW,WAAA,KAAK,YAAY,IAAI,KAAK,GAAG,GAAG,QAAQ,QAAQ,aAAa,QAAQ,CAAY;AAAA,EAC5F;ACjDgB,WAAA,UACZ,GACA,GACA,aACA,aACA,WAAW,GACX,SAAiB,KAAK,KAAK,GAC/B;AACQ,WAAA,KAAK,IAAI,SAAS,QAAQ,KAAK,KAAK,KAAK,IAElC,KACF,WAAW,GAAG,GAAG,WAAW,EAC5B,YACA,WAAW,GAAG,GAAG,WAAW,EAC5B,aAGT,KAAK,cACL,KACK,IAAI,GAAG,GAAG,aAAa,QAAQ,UAAU,EAAI,EAC7C,IAAI,GAAG,GAAG,aAAa,UAAU,QAAQ,EAAK,EAC9C,cAEE;AAAA,EACX;AClBA,SAAO,iBAAiBC,kBAAS,WAAW;AAAA,IACxC,WAAW,EAAE,OAAO,UAAU;AAAA,IAC9B,iBAAiB,EAAE,OAAO,gBAAgB;AAAA,IAC1C,gBAAgB,EAAE,OAAO,eAAe;AAAA,IACxC,oBAAoB,EAAE,OAAO,mBAAmB;AAAA,IAChD,oBAAoB,EAAE,OAAO,mBAAmB;AAAA,IAChD,kBAAkB,EAAE,OAAO,iBAAiB;AAAA,IAC5C,UAAU,EAAE,OAAO,SAAS;AAAA,EAChC,CAAC;;"}