function roundedShapeArc(g, points, radius) {
  const vecFrom = (p, pp) => {
    const x = pp.x - p.x, y = pp.y - p.y, len = Math.sqrt(x * x + y * y), nx = x / len, ny = y / len;
    return { len, nx, ny };
  }, sharpCorner = (i, p) => {
    i === 0 ? g.moveTo(p.x, p.y) : g.lineTo(p.x, p.y);
  };
  let p1 = points[points.length - 1];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i % points.length], pRadius = p2.radius ?? radius;
    if (pRadius <= 0) {
      sharpCorner(i, p2), p1 = p2;
      continue;
    }
    const p3 = points[(i + 1) % points.length], v1 = vecFrom(p2, p1), v2 = vecFrom(p2, p3);
    if (v1.len < 1e-4 || v2.len < 1e-4) {
      sharpCorner(i, p2), p1 = p2;
      continue;
    }
    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx), radDirection = 1, drawDirection = !1;
    v1.nx * v2.nx - v1.ny * -v2.ny < 0 ? angle < 0 ? angle = Math.PI + angle : (angle = Math.PI - angle, radDirection = -1, drawDirection = !0) : angle > 0 && (radDirection = -1, drawDirection = !0);
    const halfAngle = angle / 2;
    let cRadius, lenOut = Math.abs(
      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
    );
    lenOut > Math.min(v1.len / 2, v2.len / 2) ? (lenOut = Math.min(v1.len / 2, v2.len / 2), cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle))) : cRadius = pRadius;
    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection, cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection, startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection, endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
    i === 0 && g.moveTo(
      cX + Math.cos(startAngle) * cRadius,
      cY + Math.sin(startAngle) * cRadius
    ), g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection), p1 = p2;
  }
}
function roundedShapeQuadraticCurve(g, points, radius) {
  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2), pointLerp = (p1, p2, t) => ({
    x: p1.x + (p2.x - p1.x) * t,
    y: p1.y + (p2.y - p1.y) * t
  }), numPoints = points.length;
  for (let i = 0; i < numPoints; i++) {
    const thisPoint = points[(i + 1) % numPoints], pRadius = thisPoint.radius ?? radius;
    if (pRadius <= 0) {
      i === 0 ? g.moveTo(thisPoint.x, thisPoint.y) : g.lineTo(thisPoint.x, thisPoint.y);
      continue;
    }
    const lastPoint = points[i], nextPoint = points[(i + 2) % numPoints], lastEdgeLength = distance(lastPoint, thisPoint);
    let start;
    if (lastEdgeLength < 1e-4)
      start = thisPoint;
    else {
      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
      start = pointLerp(
        thisPoint,
        lastPoint,
        lastOffsetDistance / lastEdgeLength
      );
    }
    const nextEdgeLength = distance(nextPoint, thisPoint);
    let end;
    if (nextEdgeLength < 1e-4)
      end = thisPoint;
    else {
      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
      end = pointLerp(
        thisPoint,
        nextPoint,
        nextOffsetDistance / nextEdgeLength
      );
    }
    i === 0 ? g.moveTo(start.x, start.y) : g.lineTo(start.x, start.y), g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y);
  }
}
function drawRoundedShape(points, radius, useQuadraticCurve) {
  return points.length < 3 ? this : (useQuadraticCurve ? roundedShapeQuadraticCurve(this, points, radius) : roundedShapeArc(this, points, radius), this.closePath());
}
export {
  drawRoundedShape
};
//# sourceMappingURL=drawRoundedShape.mjs.map
