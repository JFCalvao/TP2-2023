{"version":3,"file":"drawRoundedShape.js","sources":["../src/drawRoundedShape.ts"],"sourcesContent":["import type { IPointData } from '@pixi/core';\nimport type { Graphics } from '@pixi/graphics';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param {PIXI.Graphics} g - Graphics to be drawn on.\n * @param {(IPointData & { radius?: number })[]} points - Corners of the shape to draw. Minimum length is 3.\n * @param {number} radius - Corners default radius.\n */\nfunction roundedShapeArc(\n    g: Graphics,\n    points: (IPointData & { radius?: number })[],\n    radius: number\n): void\n{\n    const vecFrom = (p: IPointData, pp: IPointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: IPointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param {PIXI.Graphics} g - Graphics to be drawn on.\n * @param {(IPointData & { radius?: number })[]} points - Corners of the shape to draw. Minimum length is 3.\n * @param {number} radius - Corners default radius.\n */\nfunction roundedShapeQuadraticCurve(\n    g: Graphics,\n    points: (IPointData & { radius?: number })[],\n    radius: number\n): void\n{\n    const distance = (p1: IPointData, p2: IPointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: IPointData, p2: IPointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y);\n    }\n}\n\n/**\n * Draw a Shape with rounded corners.\n * Supports custom radius for each point.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawRoundedShape\n * @param this\n * @param {(IPointData & { radius?: number })[]} points - Corners of the shape to draw. Minimum length is 3.\n * @param {number} radius - Corners default radius.\n * @param {boolean} useQuadraticCurve - If true, rounded corners will be drawn using quadraticCurve instead of arc.\n * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls.\n */\nexport function drawRoundedShape(\n    this: Graphics,\n    points: (IPointData & { radius?: number })[],\n    radius: number,\n    useQuadraticCurve?: boolean\n): Graphics\n{\n    if (points.length < 3)\n    {\n        return this;\n    }\n\n    if (useQuadraticCurve)\n    {\n        roundedShapeQuadraticCurve(this, points, radius);\n    }\n    else\n    {\n        roundedShapeArc(this, points, radius);\n    }\n\n    return this.closePath();\n}\n"],"names":[],"mappings":"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"}